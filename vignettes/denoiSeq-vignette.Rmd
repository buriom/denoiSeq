---
title: "denoiSeq: Differential expression analysis using a bottom up approach"
author: "Gershom Buri"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{denoiSeq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r "setup", include=FALSE}
require("knitr")
opts_knit$set(root.dir = "/home/buri/denoiSeq")
devtools::load_all(".")

```



##Introduction
In this vignette, we give a brief introduction to the denoiSeq package for  differential expression analysis of RNA and alike data. The statistical details of the methods used can be found in the related publication.

The package only performs a two group comparison and  assumes that the user has the data in the form of a named matrix of integers that contains counts from both groups. Each *i,j* element of this matrix corresponds to counts for gene *i* in sample *j* whereby  *j* has been derived from one of the two groups (conditions), A and B. Prior to analysis, the counts from different samples are normalised in order to be comparable. We then perform differential analysis to determine if there is a signal of significant difference between the counts in the same row for different conditions. In doing so, the primary parameter of interest is *N*.

The package is based on a bottom up model for PCR sequencing developed by  [@ndifon2012chromatin] which culminates into a  superposition of the binomial and negative binomial as the distribution for the counts. This distribution has three main parameters, i.e *N, p* and *f* which represent the initial copy number before amplification, the amplification efficiency and the dilution rate, respectively. Bayesian inference is used to estimate the model parameters. Uniform priors are used for parameters *p* and *f* and a non informative prior is used for *N*.

##Preparation
We begin the analysis by creating a readsData object to handle the summarised data. This object has six slots namely; counts, geneNames, replicates, initValues, stepSize and output. The first four slots are specified before the analysis and the latter (output) is used to catch the results of the Bayesian inference and is set inside the `results` function. Before we can create the readsData object, we first load the package and thereafter, the data.
```
library(denoiSeq)
load("data/simdat.RData")
```
The simdat dataset contains 750 genes (throughout this document, gene will be used synonymously for any genomic event) with 5 samples for each condition summarised as a 750 by 10 integer matrix. The first half of the genes are not different and the other half are different across the conditions.
```
head(simdat)
```
Because Bayesian inference is computationally intensive, users are advised to perform pre-filtering before creating the readsData object, in order to save time. An example would be
```
simdat <- simdat[ rowSums(simdat) > 10, ]
```
to eliminate the lowly expressed genes  since it's hard to extract a difference signal in these. A threshold of 10 was chosen to represent one count for a gene in each of the 10 samples but any other appropriate value can be chosen. 

We notice that in this case, the count matrix has no gene names and so we have to specify the geneNames slot.
```
genenames <- as.character(1:750)
```
We then create a readsData object.
```
RD <- new("readsData", counts = simdat,geneNames = genenames)
```
With the exception of  output, all the other slots are set to default values. See the class documentation for details. In the event that  the object has been formed, the default values can be altered using `setReplicates`,`setInitValues` and `setStepSizes` methods.

##Bayesian Inference
Once the readsData is in place, we implement Bayesian inference by calling the `results` function on it and specifying the number of steps for posterior sampling and the number  steps to be used for step size tuning.
```
steps <- 100
tuningSteps <- 30
BI <- denoiseq(RD, steps, tuningSteps)
```
The tuning steps are defaulted to a third of the sampling steps. `denoiSeq` returns the same readsData object, but with the output slot filled.

In this example, the above chunk of code run for about 1.5 minutes on my core i5, 8GB memory PC. We note that 100 steps is a very small number of iterations to attain adequately accurate results. This piece of code is just meant for instruction purposes. Typical runs should have at least 3000 steps which about a third of those used for step size tuning. A smaller dataset is used in the case study below.

##Differential analysis
The results of the inference are used to determine differential analysis. This is implemented by the `results` function which returns a data frame with three columns; the log2 fold change (log2FC), the standard error of the log2 fold change (lgfcSE) and the test static (stat), and as many rows as the number of genes.
```
rez <- results(BI,steps, tuningSteps)
head(rez)
```
`results` takes the same parameters as `denoiseq` with an additional `rope_limits` parameter, defaulted to 0.5. This parameter reflects the extent of fold change that we consider non-significant.

##Other functions
For diagnostic purposes about the behavior of the sampler, the package has the `getSamplesOf` function that takes a parameter name (gene name for the `N_i`s) and returns a vector of samples for it. The other parameters are, a readsData object with a populated output slot, the number of steps of sampling and the condition for the `N_i`s. Instead of a gene name, the function can also take the row index.
```
N50 <- getSamplesOf(BI,"50",steps,condition = "B")
```
With these samples, diagnostics such as plotting a history plot and determining the auto-lag coefficient can be performed.
```
acceptance_rate <- length(unique(N50))/steps
plot(N50,type="l", main = "History plot of N50")
AL <- acf(N50, lag.max = 100,type = c("correlation"),plot = T)
```
If one wishes, they can also have a look at the  tuned step sizes using `tunedStepSize`. It takes the output updated readsData object as its only parameter.
```
SS <- tunedStepSize(BI)
```
The return can then be set to the `initValues` slot for another run of Gibbs sampling implemented in `results`.

##Case study: Analysis of the RNA-Seq Data
###Introduction
In this case study, we will use the ERCC dataset which contains data from biological replicates of three cell lines that were characterised as part of the ENCODE project [@djebali2012landscape]. This dataset contains  mixture of 92 spike-in synthetic oligonucleotides that
   are mixed into samples A and B at four mixing ratios: 1/2, 2/3, 1 and 4. It has five samples for each condition. All other ratios are considered different apart from 1.

###Reading in the data


```{r, echo=TRUE}
load("ERCC.RData") 
dim(ERCC)
```
```
head(ERCC, 4)
```
```{r, echo=FALSE, results='asis'}
knitr::kable(head(ERCC, 4))
```

###Pre-filtering
```{r, echo=TRUE}
ERCC <- ERCC[rowSums(ERCC)>10,]
dim(ERCC)
```

###Creating the readsData object
Since the count matrix has row names, the geneNames slot has been set by default.
```{r, echo=TRUE}
reps <- list(A=1:5,B=6:10)
initvalues = list(N_A = rep(1, dim(ERCC)[1]), N_B = rep(1,dim(ERCC)[1]), p = 0.0001, f = 0.01)
RD2 <- new("readsData", counts = ERCC,replicates = reps, initValues = initvalues)
```

###Bayesian Inference
The tuningSteps argument has been set to the default `value  = floor(steps/3)`.
```{r, echo=TRUE}
steps <- 100
BI2 <- denoiseq(RD2, steps)
```

###Differential expression analysis
We explicitly set the value for the 'rope_limits' argument.
```{r, echo=TRUE}
rope = 0.5
rez2 <- results(BI2,steps)
```
```
head(rez2)
```
```{r}
knitr::kable(head(rez2))
```

A threshold value of the statistic is then chosen to determine significance.

### Diagnostics
```{r, echo=TRUE}
samples <- getSamplesOf(BI2,"ERCC-00051",steps)
acceptance_rate <- length(unique(samples))/steps
acceptance_rate
```

```{r, fig.show='hold'}
plot(samples,type="l", main = "History plot of ERCC-00051")
AL <- acf(samples, main = "Auto lag plot of ERCC-00051", lag.max = 100,type = c("correlation"),plot = T)
```

##session info
```{r,echo=TRUE}
sessionInfo()
```

##References



