#_______________________________________________________________________________

# Create the base readsData class
#_______________________________________________________________________________

#' An S4 class to represent summarised counts and the output of Bayesian inference.
#'
#' @slot counts A positive integer matrix containing summarised counts for each
#'  genomic event (genes, exons, transcripts, etc)  in the two conditions.
#' @slot replicates A list containing the indices of the columns in each of the two
#' conditions. It is defaulted to A = 1:5, B = 6:10.
#' @slot geneNames A character vector containing the names of the genomic event. Is is
#' appropriately defaulted to names of a the matrix.
#' @slot initValues A list containing initial values for each parameter. Defaulted to \emph{N_A} = rep(1, nrow(counts)),\emph{N_B} = rep(1, nrow(counts)),\emph{p}= 0.0001, \emph{f} = 0.01
#' @slot stepSizes A list containing step sizes for sampling each parameter. Defaulted to stepsizeN_A = rep(1, nrow(counts)),stepsizeN_B = rep(1, nrow(counts)),stepsize_p= 1e3, stepsizeN_A = 5e7
#' @slot output A list containing the parameter samples generated by Bayesian inference. It can only be  filled
#' inside the results function.
#'
#' @name readsData
readsData <- setClass(
  # Set the name for the class
  "readsData",

  # Define the slots
  slots = c(
    counts = "matrix",
    geneNames = "character",
    replicates   = "list",
    initValues   = "list",
    stepSizes   = "list",
    output = "list"
  )
)

#Initializing
setMethod ("initialize", signature  = "readsData",
           definition = function (.Object,

                                  counts,
                                  geneNames = rownames(counts),
                                  replicates = list(A = 1:(ncol(counts)/2),B= (ncol(counts)/2+1):ncol(counts)),
                                  stepSizes = list(stepsizeN_A = rep(1, nrow(counts)),
                                                    stepsizeN_B = rep(1,nrow(counts)),
                                                    stepsize_p = 5e+07, stepsize_f = 1e3),
                                  initValues = list(N_A = rep(1, nrow(counts)),
            N_B = rep(1,nrow(counts)), p = 0.0001, f = 0.01)){
             .Object@counts <- counts
             .Object@replicates <- replicates
             .Object@stepSizes <- stepSizes
             .Object@geneNames <- geneNames
             .Object@initValues <- initValues
             validObject(.Object)
             return (.Object)
           })

validity=function(object)
{
  rval <- NULL
  if( nrow(object@counts) != length(object@geneNames) ){
    return("reads and geneNamess don't match")
  }
  else if(sum(object@counts < 0)>0){
    return("counts cannot be negative")
  }
  else return(TRUE)
}

setValidity( "readsData",validity)
#__________________________________________________________

#initValues
#__________________________________________________________
#generic for setting the ouput slot

setGeneric(name="setInitValues",
           def=function(object,initval)
           {
             standardGeneric("setInitValues")
           }
)

#' Mutator method for the initValues slot of the readsData object.
#'
#' Alters the value of the initValues slot.
#'
#' @param object a readsData object
#' @param initval A list of initial values for all the  parameters.
#' @return The same readsData object with the initValues slot updated.
#'
#' @examples
#' RD <- new("readsData",counts = ERCC)
#' initvals <- list(N_A = rep(2, 92),N_B = rep(1.5,92), p = 0.0005, f = 0.03)
#' RD <- setInitValues(RD,initvals)
#' RD@initValues
#' @export

setMethod(f="setInitValues",
          signature="readsData",
          definition=function(object,initval)
          {
            object@initValues <- initval
            return(object)
          }
)
#______________________________________________________________

#stepSizes
#_______________________________________________________________
#generic for setting the steSizes slot

setGeneric(name="setStepSizes",
           def=function(object,stepSizesval)
           {
             standardGeneric("setStepSizes")
           }
)
#' Mutator method for the stepSizes slot of the readsData object.
#'
#' Alters the value of the stepSizes slot.
#'
#' @param object a readsData object.
#' @param stepSizesval A list of step sizes for all the  parameters.
#' @return The same readsData object with the stepSizes slot updated.
#' @examples
#' RD <- new("readsData",counts = ERCC)
#' ss <- list(N_A = rep(2, 92),N_B = rep(1.5,92), p = 3e5, f = 3.5e7)
#' RD <- setStepSizes(RD,ss)
#' RD@stepSizes
#' @export

setMethod(f="setStepSizes",
          signature="readsData",
          definition=function(object,stepSizesval)
          {
            object@stepSizes <- stepSizesval
            return(object)
          }
)
#______________________________________________________________

#replicates
#_______________________________________________________________
#method for setting the ouput slot

setGeneric(name="setReplicates",
           def=function(object,repsval)
           {
             standardGeneric("setReplicates")
           }
)
#' Mutator method for the replicates slot of the readsData object.
#'
#' Alters the value of the replicates slot.
#'
#' @param object a readsData object.
#' @param repsval A list of column indices for the samples in each condition.
#' @return The same readsData object with the replicates slot updated.
#'
#' @examples
#' RD <- new("readsData",counts = ERCC)
#' reps <- list(A = c(2,4,5,3,10),B = c(9,7,1,8,6))
#' RD <- setReplicates(RD,reps)
#' RD@replicates
#'
#' @export
#'
setMethod(f="setReplicates",
          signature="readsData",
          definition=function(object,repsval)
          {
            object@replicates <- repsval
            return(object)
          }
)

#______________________________________________________________

#setOutput
#_______________________________________________________________
#method for setting the ouput slot

setGeneric(name="setOutput",
           def=function(object,outval)
           {
             standardGeneric("setOutput")
           }
)
#' Mutator method for the output slot of the readsData object.
#'
#' sets the value of the outout slot.
#'
#' @param object a readsData object.
#' @param outval A list of the output from bayesian inference.
#' @return The same readsData object with the output slot updated.
#'

setMethod(f="setOutput",
          signature="readsData",
          definition=function(object,outval)
          {
            object@output <- outval
            return(object)
          }
)

# replicates <- list(A=1:5,B=6:10)
# load("/home/buri/denoiSeq/data/ERCC.RData")
# geneNames <- row.names(ERCC)
# initValues = list(N_A = rep(1, 71),
# N_B = rep(1,71), p = 0.0001, f = 0.01)
# CD <- new("readsData", counts = ERCC,geneNames = geneNames,initValues = initValues)

# ##not part of package
# Vignettes  are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:
#
#   - Never uses retina figures
# - Has a smaller default figure size
# - Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style
#
# ## Vignette Info
#
# Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.
# ```{r}
# # Add two numbers together
# add <- function(a, b) a + b
# add(10, 20)
# ```
#
# ## Styles
#
# The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:
#
#   output:
#   rmarkdown::html_vignette:
#   css: mystyles.css
#
# ## Figures
#
# The figure sizes have been customised so that you can easily put two images side-by-side.
#
# ```{r, fig.show='hold'}
# plot(1:10)
# plot(10:1)
# ```
#
# You can enable figure captions by `fig_caption: yes` in YAML:
#
#   output:
#   rmarkdown::html_vignette:
#   fig_caption: yes
#
# Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.
#
# ## More Examples
#
# You can write math expressions, e.g. $Y = X\beta + \epsilon$,  and tables, e.g. using `knitr::kable()`.
#
# ```{r, echo=FALSE, results='asis'}
# knitr::kable(head(mtcars, 10))
# ```
#
# Also a quote using `>`:
#
#   > "He who gives up [code] safety for [code] speed deserves neither."
# ([via](https://twitter.com/hadleywickham/status/504368538874703872))
